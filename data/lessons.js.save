// data/lessons.js

export const lessons = [
  {
    id: "bit-vs-qubit",
    title: "Lesson 1: Bit vs Qubit",
    level: "Beginner",
    tags: ["intro", "qubits", "concepts"],
    next: "superposition",
    content: `
A classical bit can be 0 or 1. That's it.

A qubit is different: it can be 0, 1, or a superposition of both at once.

You can think of it like this:

- Bit  => coin lying flat: HEADS or TAILS.
- Qubit => coin spinning: it’s sort of both, until you stop it.

Mathematically, we write a qubit as:

|ψ⟩ = a|0⟩ + b|1⟩

where a and b are complex numbers and |a|² + |b|² = 1.

When you measure a qubit:

- You see 0 with probability |a|²
- You see 1 with probability |b|²

But before measurement, it's in that mixed, “both at once” state we call superposition.
    `,
  },
  {
    id: "superposition",
    title: "Lesson 2: Superposition",
    level: "Beginner",
    tags: ["intro", "superposition", "probability"],
    next: "measurement",
    content: `
Superposition is the ability of a qubit to be in a combination of 0 and 1.

If we apply a Hadamard gate (H) to |0⟩, we get:

|ψ⟩ = (|0⟩ + |1⟩) / √2

This means:

- P(0) = 1/2
- P(1) = 1/2

Key idea: superposition lets a quantum computer explore many possibilities in parallel instead of checking them one by one.

You can think of superposition as a probability cloud that only becomes a definite value when measured.
    `,
  },
  {
    id: "measurement",
    title: "Lesson 3: Measurement",
    level: "Beginner",
    tags: ["intro", "measurement", "probability"],
    next: "bloch-sphere",
    content: `
Measurement turns a fuzzy quantum state into a definite classical value.

Example: if a qubit is in state

|ψ⟩ = (|0⟩ + |1⟩) / √2

and we measure it in the standard basis, then:

- We get 0 with probability 1/2
- We get 1 with probability 1/2

After measurement, the qubit is no longer in superposition. It “collapses”:

- If we saw 0, the qubit becomes |0⟩
- If we saw 1, the qubit becomes |1⟩

Quantum algorithms carefully control when measurement happens so they can use superposition and interference first, then read out useful answers at the end.
    `,
  },
  {
    id: "bloch-sphere",
    title: "Lesson 4: The Bloch Sphere (Intuition)",
    level: "Beginner / Intermediate",
    tags: ["bloch-sphere", "visualization", "geometry"],
    next: "single-qubit-gates",
    content: `
The Bloch sphere is a way to visualize a single qubit as a point on a sphere.

- North pole  = |0⟩
- South pole  = |1⟩
- Equator points = equal superpositions like (|0⟩ + e^{iφ}|1⟩) / √2

Any pure 1-qubit state can be written as:

|ψ⟩ = cos(θ/2)|0⟩ + e^{iφ} sin(θ/2)|1⟩

So:

- θ controls “how much” 0 vs 1 you have.
- φ controls the relative phase between them.

Thinking in terms of rotations on the Bloch sphere is super useful: most single-qubit gates are just rotations around certain axes.
    `,
  },
  {
    id: "single-qubit-gates",
    title: "Lesson 5: Single-Qubit Gates",
    level: "Beginner / Intermediate",
    tags: ["gates", "circuits", "bloch-sphere"],
    next: "entanglement",
    content: `
Single-qubit gates are operations that transform qubit states. They are represented by 2×2 unitary matrices.

Some core gates:

- X gate (NOT)
  - Flips |0⟩ ↔ |1⟩
  - Matrix: [[0, 1], [1, 0]]

- Z gate
  - Leaves |0⟩ alone, flips the phase of |1⟩
  - |0⟩ → |0⟩, |1⟩ → -|1⟩

- H gate (Hadamard)
  - Creates superposition from basis states:
    - |0⟩ → (|0⟩ + |1⟩)/√2
    - |1⟩ → (|0⟩ - |1⟩)/√2

- Phase gates (S, T, etc.)
  - Add specific phase factors to |1⟩.

On the Bloch sphere, these gates correspond to rotations around the X, Y, or Z axes.
    `,
  },
  {
    id: "entanglement",
    title: "Lesson 6: Entanglement",
    level: "Intermediate",
    tags: ["entanglement", "multi-qubit", "correlations"],
    next: "interference",
    content: `
Entanglement is a special kind of correlation between qubits that has no classical analog.

Example: the 2-qubit Bell state

|Φ⁺⟩ = (|00⟩ + |11⟩) / √2

If we measure the first qubit:

- With probability 1/2, we get 0 and the state becomes |00⟩
- With probability 1/2, we get 1 and the state becomes |11⟩

Either way, the two qubits always match. If the first is 0, the second is 0. If the first is 1, the second is 1.

This correlation is stronger than anything possible with classical random variables and is a key resource for quantum computing and quantum communication.
    `,
  },
  {
    id: "interference",
    title: "Lesson 7: Interference",
    level: "Intermediate",
    tags: ["interference", "superposition", "gates"],
    next: "multi-qubit-circuits",
    content: `
Interference is how quantum amplitudes can add or cancel out, like waves.

If we apply H, then some gate, then H again, probabilities can:

- Increase for some outcomes (constructive interference)
- Drop to zero for others (destructive interference)

Toy example:

Start |0⟩

1. H → (|0⟩ + |1⟩)/√2
2. Z → (|0⟩ − |1⟩)/√2
3. H again → |1⟩

The final result is always |1⟩, even though we started in |0⟩. That’s pure interference.
    `,
  },
  {
    id: "multi-qubit-circuits",
    title: "Lesson 8: Multi-Qubit Circuits",
    level: "Intermediate",
    tags: ["circuits", "multi-qubit", "cnot"],
    next: "deutsch-algorithm",
    content: `
With multiple qubits, the state space grows exponentially.

- 1 qubit → 2 basis states (|0⟩, |1⟩)
- 2 qubits → 4 states (|00⟩, |01⟩, |10⟩, |11⟩)
- 3 qubits → 8 states
- n qubits → 2ⁿ states

We build multi-qubit circuits using:

- Single-qubit gates on specific wires
- Controlled gates (like CNOT)
  - Control qubit and target qubit
  - Flips the target if the control is 1

These circuits are how we build actual algorithms: prepare an input state, apply a sequence of gates, then measure.
    `,
  },
  {
    id: "deutsch-algorithm",
    title: "Lesson 9: Your First Algorithm (Deutsch)",
    level: "Intermediate",
    tags: ["algorithms", "deutsch", "oracles"],
    next: "quantum-vs-classical-thinking",
    content: `
Deutsch's algorithm is a tiny example where a quantum computer can solve a problem in fewer function calls than a classical one.

Problem (simplified):

You are given a mystery function f(x) that returns 0 or 1.
- It is either constant (same output for x = 0 and x = 1)
- Or balanced (different outputs for x = 0 and x = 1)

Classically, you must check f(0) and f(1) → 2 calls.

Quantumly, using a clever superposition and interference trick, you can determine whether f is constant or balanced in 1 call.

Deutsch’s algorithm is small, but it shows the core idea:
- Put inputs in superposition
- Let the function act on all of them at once
- Use interference to extract a property of the function with fewer queries.
    `,
  },
  {
    id: "quantum-vs-classical-thinking",
    title: "Lesson 10: Quantum vs Classical Thinking",
    level: "Beginner / Intermediate",
    tags: ["concepts", "mindset", "comparison"],
    next: "state-vectors",
    content: `
Classical algorithms think in terms of:

- Bits that are 0 or 1
- Deterministic or probabilistic steps
- Checking possibilities mostly one-by-one

Quantum algorithms think in terms of:

- State vectors and amplitudes
- Parallel exploration of many possibilities via superposition
- Careful use of interference to boost correct answers and cancel incorrect ones
- Measurement only at the end to read out useful classical information

The real power of quantum computing:

- Not that it is “faster at everything”
- But that for some problems (like factoring, search, simulation of quantum systems) it can offer dramatic speedups or capabilities that classical computers struggle with.
    `,
  },

  // --- MORE MATH / REPRESENTATIONS ---

  {
    id: "state-vectors",
    title: "Lesson 11: Quantum States as Vectors",
    level: "Intermediate",
    tags: ["math", "state-vectors", "linear-algebra"],
    next: "dirac-notation",
    content: `
Behind the scenes, a qubit is just a 2D complex vector:

|0⟩ = [1, 0]ᵀ
|1⟩ = [0, 1]ᵀ

A general qubit:

|ψ⟩ = a|0⟩ + b|1⟩  ↔  [a, b]ᵀ

For 2 qubits, the state is a 4D vector. Basis states:

|00⟩ = [1, 0, 0, 0]ᵀ
|01⟩ = [0, 1, 0, 0]ᵀ
|10⟩ = [0, 0, 1, 0]ᵀ
|11⟩ = [0, 0, 0, 1]ᵀ

The whole quantum state always has length 1 (normalized). Gates act as matrices that multiply these vectors.
    `,
  },
  {
    id: "dirac-notation",
    title: "Lesson 12: Dirac Notation Basics",
    level: "Intermediate",
    tags: ["math", "dirac-notation", "inner-product"],
    next: "tensor-products",
    content: `
Dirac notation is the compact language physicists use for quantum states.

- Ket |ψ⟩ represents a column vector (a state)
- Bra ⟨ψ| represents the conjugate transpose row vector

Inner product:

⟨φ|ψ⟩ is a complex number that tells you “overlap” between states.

- If ⟨φ|ψ⟩ = 0 → orthogonal states (perfectly distinguishable)
- If |⟨φ|ψ⟩| = 1 → same state up to a phase

Projecting onto a basis, measuring probabilities, and checking normalization are all easy in this notation once you get used to it.
    `,
  },
  {
    id: "tensor-products",
    title: "Lesson 13: Tensor Products and Multi-Qubit Math",
    level: "Intermediate",
    tags: ["math", "tensor-product", "multi-qubit"],
    next: "circuits-and-matrices",
    content: `
To combine qubits mathematically, we use the tensor product (⊗).

If

|ψ⟩ = a|0⟩ + b|1⟩
|φ⟩ = c|0⟩ + d|1⟩

then the 2-qubit state is:

|ψ⟩ ⊗ |φ⟩ = ac|00⟩ + ad|01⟩ + bc|10⟩ + bd|11⟩

Tensor products:

- Grow the dimension of the state space (2 → 4 → 8 → ...).
- Are how we represent multi-qubit states, gates, and operations.

Understanding tensor products is key to understanding entanglement and multi-qubit circuits at a deeper level.
    `,
  },
  {
    id: "circuits-and-matrices",
    title: "Lesson 14: Quantum Circuits as Matrices",
    level: "Intermediate",
    tags: ["math", "matrices", "circuits"],
    next: "reversible-computation",
    content: `
Every quantum circuit corresponds to a big unitary matrix U.

- Single-qubit gates → 2×2 matrices
- 2-qubit gates → 4×4 matrices
- n-qubit circuits → 2ⁿ×2ⁿ matrices

The overall effect of a circuit is just matrix multiplication:

|ψ_out⟩ = U |ψ_in⟩

You almost never write huge matrices by hand, but this view is important:

- It explains why quantum operations must be reversible (unitary).
- It connects quantum computing to linear algebra, which is the main math behind everything here.
    `,
  },
  {
    id: "reversible-computation",
    title: "Lesson 15: Reversible Computation and Toffoli Gate",
    level: "Intermediate",
    tags: ["reversible", "toffoli", "logic"],
    next: "grover-intuition",
    content: `
Quantum gates must be reversible, but many classical operations are not (like AND, OR, ERASE).

Reversible computing uses gates that:

- Don’t lose information
- Can be run backward uniquely

The Toffoli gate (CCNOT):

- Has 3 bits: 2 controls, 1 target
- Flips the target if both controls are 1

Toffoli is important because:

- It’s universal for reversible classical computation.
- It appears in quantum circuits that mix classical logic with quantum registers (e.g., in oracles for algorithms like Grover and Shor).
    `,
  },

  // --- ALGORITHMS / ADVANCED CONCEPTS ---

  {
    id: "grover-intuition",
    title: "Lesson 16: Grover’s Algorithm (Intuition)",
    level: "Intermediate",
    tags: ["algorithms", "grover", "search"],
    next: "shor-intuition",
    content: `
Grover’s algorithm is a quantum search algorithm.

Problem (simplified):
- You have N items and 1 marked “winner.”
- Classically, you might have to check ~N/2 items on average.
- Grover finds the winner in ~√N steps.

Core idea:

1. Put all states into equal superposition.
2. Flip the phase of the “winning” state (using an oracle).
3. Perform an “amplitude amplification” step that boosts the winner’s probability.
4. Repeat steps 2–3 about √N times.
5. Measure → you get the winning item with high probability.

Grover shows a clear quadratic speedup for unstructured search.
    `,
  },
  {
    id: "shor-intuition",
    title: "Lesson 17: Shor’s Algorithm (Intuition)",
    level: "Intermediate / Advanced",
    tags: ["algorithms", "shor", "factoring", "crypto"],
    next: "phase-estimation",
    content: `
Shor’s algorithm factors large integers exponentially faster than the best known classical algorithms.

Why it matters:
- Many cryptosystems (like RSA) rely on factoring being hard.
- A large enough, fault-tolerant quantum computer running Shor’s algorithm could break those systems.

Very high-level steps:

1. Reduce factoring to a “period finding” problem.
2. Use a quantum procedure (based on superposition and interference) to find that period.
3. Convert the period into factors of the original number.

The core quantum subroutine is called quantum phase estimation, which is a more general tool than just factoring.
    `,
  },
  {
    id: "phase-estimation",
    title: "Lesson 18: Quantum Phase Estimation (QPE)",
    level: "Advanced (Conceptual)",
    tags: ["algorithms", "phase-estimation", "eigenvalues"],
    next: "noise-and-decoherence",
    content: `
Quantum Phase Estimation (QPE) is a central algorithmic primitive.

Given:
- A unitary U and one of its eigenstates |ψ⟩ with eigenvalue e^{2πiφ}
- QPE estimates the phase φ to high precision.

Rough intuition:

1. Prepare many control qubits in superposition.
2. Apply controlled-U, controlled-U², controlled-U⁴, etc.
3. Perform an inverse quantum Fourier transform.
4. Measure the control register to read out an estimate of φ.

QPE is the engine behind Shor’s algorithm and many quantum simulation algorithms in chemistry and physics.
    `,
  },

  // --- NOISE / HARDWARE / ERROR CORRECTION ---

  {
    id: "noise-and-decoherence",
    title: "Lesson 19: Noise and Decoherence",
    level: "Intermediate",
    tags: ["hardware", "noise", "decoherence"],
    next: "error-correction",
    content: `
Real quantum hardware is noisy.

Main issues:

- Decoherence:
  - Qubits lose their quantum state over time due to interactions with the environment.
- Gate errors:
  - Operations are not perfectly accurate.
- Readout errors:
  - Measurement gives the wrong result with some probability.

This is why current devices are called NISQ:
- Noisy
- Intermediate-Scale
- Quantum

Understanding noise is essential for making algorithms that can work on today’s imperfect hardware.
    `,
  },
  {
    id: "error-correction",
    title: "Lesson 20: Quantum Error Correction (High Level)",
    level: "Intermediate / Advanced",
    tags: ["error-correction", "codes", "fault-tolerance"],
    next: "hardware-superconducting",
    content: `
Quantum error correction (QEC) protects logical qubits using many physical qubits.

Key ideas:

- You can’t just copy an unknown quantum state (no-cloning theorem).
- Instead, you spread the information across entangled states of multiple qubits.
- If some physical qubits get disturbed, you can detect and correct errors without learning the logical state itself.

Codes like the surface code are leading candidates for building large, fault-tolerant quantum computers. They use a 2D grid of qubits with repeated measurements to detect error patterns.
    `,
  },
  {
    id: "hardware-superconducting",
    title: "Lesson 21: Quantum Hardware – Superconducting Qubits",
    level: "Intermediate",
    tags: ["hardware", "superconducting", "cryogenics"],
    next: "hardware-trapped-ions",
    content: `
Superconducting qubits are one of the leading hardware platforms.

Basics:

- Use tiny superconducting circuits at millikelvin temperatures.
- Qubit states correspond to different current or energy levels in the circuit.
- Microwave pulses implement gates by driving transitions between levels.

Pros:
- Fast gates.
- Fabrication can leverage some classical chip-making techniques.

Cons:
- Need complex cryogenic systems.
- Coherence times are limited but improving.

Companies like IBM, Google, and Rigetti use superconducting qubits.
    `,
  },
  {
    id: "hardware-trapped-ions",
    title: "Lesson 22: Quantum Hardware – Trapped Ions",
    level: "Intermediate",
    tags: ["hardware", "trapped-ions", "lasers"],
    next: "nisq-era",
    content: `
Trapped-ion quantum computers use individual ions (charged atoms) held in electromagnetic traps.

Basics:

- Qubit states are different internal energy levels of the ion.
- Lasers are used to implement gates and measurements.
- Ions naturally form ordered chains, making it easier to address them individually.

Pros:
- Very high-fidelity gates.
- Long coherence times.

Cons:
- Gate speeds are slower than superconducting qubits.
- Scaling to very large numbers of ions is an engineering challenge.

Companies like IonQ and Quantinuum use trapped ions.
    `,
  },
  {
    id: "nisq-era",
    title: "Lesson 23: The NISQ Era and Its Limits",
    level: "Intermediate",
    tags: ["nisq", "hardware", "limitations"],
    next: "quantum-sdks",
    content: `
We are currently in the NISQ era:

- Noisy: errors are significant.
- Intermediate-Scale: tens to a few hundred qubits.
- Quantum: but not yet fully fault-tolerant.

Implications:

- Some algorithms (like Shor for breaking RSA) are not practical yet.
- But we can still explore:
  - Variational algorithms (VQE, QAOA).
  - Quantum machine learning prototypes.
  - Quantum simulation of small systems.

The NISQ era is about learning how to best use imperfect hardware and figuring out what real advantages we can get before full error correction arrives.
    `,
  },

  // --- SDKs / HYBRID ALGORITHMS / APPLICATIONS ---

  {
    id: "quantum-sdks",
    title: "Lesson 24: Quantum SDKs and Cloud Backends",
    level: "Intermediate",
    tags: ["sdk", "cloud", "qiskit", "cirq"],
    next: "first-qiskit-circuit",
    content: `
Quantum SDKs let you write, simulate, and run quantum circuits from your laptop.

Popular SDKs:

- Qiskit (Python, IBM)
- Cirq (Python, Google)
- Braket SDK (AWS)
- CUDA Quantum / CUDA-Q (NVIDIA)

They provide:

- Circuit-building tools.
- Simulators for running circuits locally.
- Access to real hardware via cloud APIs.

Your learning platform can eventually act as a friendly frontend on top of these SDKs and backends.
    `,
  },
  {
    id: "first-qiskit-circuit",
    title: "Lesson 25: Your First Qiskit-Style Circuit (Conceptual)",
    level: "Intermediate",
    tags: ["sdk", "qiskit", "circuits"],
    next: "variational-algorithms",
    content: `
In Qiskit-like frameworks, circuits are built with an API instead of drawings.

Conceptual example:

1. Create a quantum circuit with 1 qubit and 1 classical bit.
2. Apply H to the qubit.
3. Measure the qubit into the classical bit.
4. Run the circuit many times (shots) and count how often you see 0 or 1.

This maps nicely to what your Playground already does:
- Prepare a state.
- Apply gates.
- Measure many times.
- Look at the statistics.

Later, your platform could export circuits from the Playground into real SDK code.
    `,
  },
  {
    id: "variational-algorithms",
    title: "Lesson 26: Variational Algorithms (VQE and QAOA)",
    level: "Intermediate / Advanced",
    tags: ["vqe", "qaoa", "hybrid", "algorithms"],
    next: "quantum-ml-overview",
    content: `
Variational algorithms are hybrids of classical and quantum computing.

General pattern:

1. Choose a parameterized quantum circuit (with angles θ).
2. Run the circuit on a quantum device and measure some cost (like energy).
3. Use a classical optimizer to tweak θ and minimize the cost.
4. Repeat until convergence.

Examples:

- VQE (Variational Quantum Eigensolver) for finding ground-state energies.
- QAOA (Quantum Approximate Optimization Algorithm) for optimization problems like MaxCut.

They are promising for NISQ hardware because they can be more tolerant of noise and use relatively shallow circuits.
    `,
  },
  {
    id: "quantum-ml-overview",
    title: "Lesson 27: Quantum Machine Learning (Overview)",
    level: "Intermediate / Advanced",
    tags: ["qml", "machine-learning", "applications"],
    next: "quantum-communication",
    content: `
Quantum machine learning (QML) explores using quantum circuits to help with ML tasks.

Ideas include:

- Quantum kernels for SVM-like methods.
- Variational quantum classifiers.
- Quantum-inspired classical algorithms.

Open questions:

- Where is the clear, practical advantage over classical ML?
- How do we encode real-world data into quantum states efficiently?

Right now, QML is an active research area with many proposals but few definitive “killer apps” yet.
    `,
  },
  {
    id: "quantum-communication",
    title: "Lesson 28: Quantum Communication and BB84",
    level: "Intermediate",
    tags: ["communication", "bb84", "qkd"],
    next: "quantum-crypto-post-quantum",
    content: `
Quantum communication uses qubits sent over channels (like fiber) to perform tasks like secure key distribution.

BB84 is a famous protocol for quantum key distribution (QKD):

- A sender encodes bits in randomly chosen bases (e.g., + or ×).
- A receiver measures in randomly chosen bases.
- Afterward, they compare bases publicly and keep only the bits where they matched.
- Eavesdropping disturbs the qubits and can be detected by error rates.

This doesn’t replace all classical crypto, but it shows how quantum physics itself can provide security guarantees.
    `,
  },
  {
    id: "quantum-crypto-post-quantum",
    title: "Lesson 29: Quantum Threats and Post-Quantum Cryptography",
    level: "Intermediate",
    tags: ["crypto", "post-quantum", "security"],
    next: "where-to-go-next",
    content: `
Large, fault-tolerant quantum computers could break some widely used cryptosystems, especially those based on factoring and discrete logs.

- Shor’s algorithm threatens schemes like RSA and some elliptic-curve cryptography.
- Grover’s algorithm provides a quadratic speedup for brute-force search, impacting symmetric key sizes.

Post-quantum cryptography (PQC):

- Classical (non-quantum) cryptosystems designed to resist quantum attacks.
- Being standardized so the world can migrate before large quantum computers exist.

Understanding this landscape is important if you care about security, networking, or finance.
    `,
  },
k
  {
    id: "where-to-go-next",
    title: "Lesson 30: Where to Go Next (Learning and Careers)",
    level: "Beginner / Intermediate",
    tags: ["careers", "learning", "next-steps"],
    next: null,
    content: `
You now have a high-level map of many core ideas in quantum computing.

Next steps could include:

- Going deeper into the math (linear algebra, complex numbers, probability).
- Taking structured online courses focused on quantum information.
- Learning one or more quantum SDKs (Qiskit, Cirq, Braket, CUDA-Q).
- Running your own circuits on real devices via the cloud.
- Following research blogs, YouTube channels, or academic papers on specific topics you like.

Career directions:

- Quantum algorithm research
- Quantum software engineering (SDKs, compilers, tooling)
- Quantum hardware engineering (devices, control electronics, cryogenics)
- Applications in chemistry, materials, optimization, and machine learning

Your platform can grow with you: as you learn, you turn your knowledge into lessons, tools, and playgrounds for the next wave of learners.
    `,
  },
];
